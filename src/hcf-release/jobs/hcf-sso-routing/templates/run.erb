#!/var/vcap/packages/ruby-2.3/bin/ruby

require 'json'
require 'open3'

# helper function to retry a command several times, with a delay between trials
def do_retry(max_tries, delay, *command)
  max_tries.times do |i|
    Process.wait Process.spawn(*command, out: ['/dev/null', File::WRONLY])
    if $?.success?
      STDOUT.puts ''
      return
    end
    STDOUT.write "\rSleeping for #{delay} seconds after #{i} attempts..."
    STDOUT.flush
    sleep delay
  end
  fail "Failed to run command #{command.join(' ')}, returned #{$?.exitstatus}"
end

def capture2(*args)
  output, status = Open3.capture2(*args)
  unless status.success?
    copy = args.dup
    if copy.length > 0
      if copy.last == 'hcf_auto_config:<%=p("uaa.clients.hcf_auto_config.secret")%>'
        copy[-1] = 'hcf_auto_config:<password>'
      end
      copy = copy.map do |value|
        if value.respond_to?(:start_with?) && value.start_with?('Authorization: bearer')
          'Authorization: bearer <token>'
        else
          value
        end
      end
    end
    fail "Failed running #{copy}"
  end
  output
end

def make_api_request(path, opts={})
  args = %W(curl --fail)
  args << $curl_ssl unless $curl_ssl.empty?
  args += ['--header', 'Accept: application/json']
  args += ['--header', "Authorization: bearer #{$token}"]
  args += ['-X', opts[:method]]  if opts.has_key? :method
  args << "http://#{$api_endpoint}#{path}"
  if opts[:stdin]
    args += %w(-d@-)
    args << { stdin_data: opts[:stdin] }
  end
  capture2(*args)
end

def register_service(service_name, user, pass, endpoint)
  # Check if the service exists
  services = JSON.load(make_api_request("/v2/service_brokers?q=name:#{service_name}"))
  service_info = services['resources'].find { |resource| resource['entity']['name'] == service_name }
  service_data = {
    name: service_name,
    broker_url: endpoint,
    auth_username: user,
    auth_password: pass,
  }.to_json
  if service_info.nil?
    # Create
    make_api_request('/v2/service_brokers', stdin: service_data)
  else
    # Update
    make_api_request("/v2/service_brokers/#{service_info['metadata']['guid']}",
                     method: 'PUT', stdin: service_data)
  end
end

$curl_ssl = '<%= properties.ssl.skip_cert_verify ? "--insecure" : "" %>'

sso_port = '<%= p("hcf_sso.port") %>'
sso_user = '<%= p("hcf_sso.username") %>'
sso_pass = "<%= p('hcf_sso.password').inspect[1..-2] %>"  # Magic inspect stuff to escape string correctly

uaa_endpoint = '<%= p("hcf.uaa.internal-url").chomp("/") %>' # UAA doesn't like extra slashes, at all.
sso_endpoint = "https://#{ENV['HCF_SSO_HOST']}.#{ENV['HCP_SERVICE_DOMAIN_SUFFIX']}:#{sso_port}"
$api_endpoint = "api-int.#{ENV['HCP_SERVICE_DOMAIN_SUFFIX']}:9022"

puts "Waiting for CC... #{$api_endpoint}"
do_retry 240, 30, *%W(curl --fail --silent #{$curl_ssl} -o /dev/null http://#{$api_endpoint}/v2/info)

puts "Waiting for UAA..."
do_retry 240, 30, *%W(curl --fail --silent #{$curl_ssl} -o /dev/null --header), 'Accept: application/json', "#{uaa_endpoint}/info"

puts "Waiting for SSO Routing service broker..."
do_retry 240, 30, *%w(curl --fail --silent --insecure), "#{sso_endpoint}/ping"

puts "Logging in to #{uaa_endpoint}..."
uaa_auth = capture2(*%W(curl --fail --silent #{$curl_ssl} --header),
                    'Accept: application/json',
                    "#{uaa_endpoint}/oauth/token",
                    *%w(-d grant_type=client_credentials -u),
                    'hcf_auto_config:<%=p("uaa.clients.hcf_auto_config.secret")%>')
$token = JSON.load(uaa_auth)['access_token']

puts "Registering SSO Routing service broker..."
register_service 'sso-routing', sso_user, sso_pass, sso_endpoint

puts "Registration of SSO Routing complete."
